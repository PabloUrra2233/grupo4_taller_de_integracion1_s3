================================================================================
EXPLICACIÓN DEL CÓDIGO - Django Restaurant Booking System
================================================================================

================================================================================
1. RESERVAINLINE (mesas/admin.py)
================================================================================

CÓDIGO:
-------
class ReservaInline(admin.TabularInline):
    model = Reserva
    extra = 0
    readonly_fields = ('usuario', 'fecha_reserva', 'hora_inicio', 'hora_fin')
    can_delete = False

EXPLICACIÓN:
-----------
Este código configura cómo se visualizan las reservas relacionadas dentro del 
panel de administración de Django, específicamente cuando estás viendo el 
detalle de otro modelo (en este caso, el modelo Mesa).

Desglose línea por línea:

1. class ReservaInline(admin.TabularInline):
   - Crea una vista "en línea" (Inline). Esto significa que te permite ver 
     objetos relacionados (Reserva) directamente dentro de la página de 
     edición del modelo padre (Mesa).
   - TabularInline significa que los datos se mostrarán en formato de tabla 
     (filas y columnas), lo cual es más compacto que el formato de pila 
     (StackedInline).

2. model = Reserva
   - Indica que este inline representa objetos del modelo Reserva.

3. extra = 0
   - Por defecto, Django muestra 3 formularios vacíos al final de la lista 
     para añadir nuevos registros rápidamente.
   - Al ponerlo en 0, le dices que no muestre ningún formulario vacío extra, 
     manteniendo la interfaz limpia.

4. readonly_fields = (...)
   - Hace que los campos 'usuario', 'fecha_reserva', 'hora_inicio' y 
     'hora_fin' sean de solo lectura. El administrador podrá ver la 
     información, pero no podrá modificarla desde esta pantalla.

5. can_delete = False
   - Deshabilita la opción de eliminar las reservas desde esta vista. El 
     botón o checkbox de eliminar no aparecerá.

EN RESUMEN:
Este bloque sirve para que, cuando entres a editar una Mesa en el admin, veas 
debajo una tabla con el historial de sus Reservas. Sin embargo, esta tabla es 
meramente informativa: no podrás borrar las reservas ni editar sus datos 
principales (usuario, fecha, hora), ni te sugerirá espacios vacíos para crear 
nuevas reservas manualmente ahí mismo.

================================================================================
2. MESAADMIN (mesas/admin.py)
================================================================================

CÓDIGO:
-------
@admin.register(Mesa)
class MesaAdmin(admin.ModelAdmin):
    list_display = ('numero_mesa', 'capacidad', 'ubicacion', 'estado')
    list_filter = ('estado', 'capacidad')
    search_fields = ('ubicacion',)
    inlines = [ReservaInline]

EXPLICACIÓN:
-----------
Este código configura la pantalla principal de administración para las Mesas. 
Define cómo se ve el listado de mesas y qué herramientas de búsqueda/filtro 
tienes disponibles.

Detalle:

1. @admin.register(Mesa)
   - Registra el modelo Mesa en el panel de administración usando esta 
     configuración personalizada. Es lo mismo que hacer 
     admin.site.register(Mesa, MesaAdmin) pero más moderno y limpio.

2. list_display = (...)
   - Controla qué columnas ves en la lista general de todas las mesas.
   - En lugar de ver solo "Mesa object (1)", verás columnas explícitas para: 
     numero_mesa, capacidad, ubicacion y estado.

3. list_filter = (...)
   - Añade un panel lateral de filtros a la derecha.
   - Te permitirá filtrar rápidamente las mesas por su estado (ej. Disponible, 
     Ocupada) o por su capacidad (ej. ver solo mesas de 4 personas).

4. search_fields = ('ubicacion',)
   - Añade una barra de búsqueda en la parte superior.
   - Te permitirá escribir texto para buscar mesas basándose en su ubicacion. 
     (Nota: si quisieras buscar por número de mesa, habría que agregarlo aquí).

5. inlines = [ReservaInline]
   - Aquí es donde se conecta con el código anterior.
   - Le dice a Django: "Cuando entre a ver el detalle de una mesa específica, 
     incrusta debajo la tabla de ReservaInline".
   - Gracias a esto, al abrir "Mesa 5", verás abajo todas las reservas que ha 
     tenido esa mesa sin tener que ir a buscarlas a otra parte.

================================================================================
3. FUNCIÓN REGISTRO (usuarios/views.py)
================================================================================

CÓDIGO:
-------
def registro(request):
    if request.method == 'POST':
        form = RegistroForm(request.POST)
        if form.is_valid():
            user = form.save()
            # Establecer manualmente el backend en el usuario
            user.backend = 'usuarios.backends.EmailBackend'
            login(request, user)
            return redirect('home')
    else:
        form = RegistroForm()
    return render(request, 'usuarios/registro.html', {'form': form})

EXPLICACIÓN:
-----------
Este código maneja la lógica de la vista de registro de usuarios. Se encarga 
de mostrar el formulario de registro y, cuando el usuario lo envía, crea la 
cuenta y lo inicia sesión automáticamente.

Paso a paso:

1. if request.method == 'POST':
   - Verifica si se están enviando datos (cuando el usuario presiona 
     "Registrarse").

2. form = RegistroForm(request.POST) y if form.is_valid():
   - Llena el formulario con los datos enviados y verifica que sean correctos 
     (que el email sea válido, las contraseñas coincidan, etc.).

3. user = form.save()
   - Si todo está bien, guarda el nuevo usuario en la base de datos.

4. user.backend = 'usuarios.backends.EmailBackend' (Importante)
   - Este es el truco clave. Normalmente, para iniciar sesión con login(), 
     Django necesita saber qué "backend" autenticó al usuario.
   - Como acabamos de crear el usuario (no pasamos por una pantalla de login 
     tradicional), esa información no existe.
   - Esta línea fuerza al sistema a recordar que este usuario debe ser 
     manejado por tu sistema de login personalizado (login con email), 
     evitando errores al intentar iniciar sesión inmediatamente.

5. login(request, user)
   - Inicia la sesión del usuario inmediatamente después de registrarse. Es 
     una buena práctica de experiencia de usuario (UX) para que no tengan que 
     ir al login después de crear la cuenta.

6. return redirect('home')
   - Envía al usuario a la página de inicio una vez completado el proceso.

7. else: form = RegistroForm()
   - Si la petición NO es POST (el usuario apenas entró a la página /registro), 
     crea un formulario vacío para que el usuario pueda escribir.

8. return render(...)
   - Muestra la plantilla HTML (usuarios/registro.html) enviándole el 
     formulario (form) para que se dibuje en pantalla.

================================================================================
4. USUARIOADMIN (usuarios/admin.py)
================================================================================

CÓDIGO:
-------
@admin.register(Usuario)
class UsuarioAdmin(UserAdmin):
    list_display = ('username', 'email', 'first_name', 'last_name', 'rol', 'is_staff')
    list_filter = ('rol', 'is_staff', 'is_superuser')
    search_fields = ('username', 'email', 'first_name', 'last_name')
    
    fieldsets = UserAdmin.fieldsets + (
        ('Información Adicional', {'fields': ('rol',)}),
    )
    
    add_fieldsets = UserAdmin.add_fieldsets + (
        ('Información Adicional', {'fields': ('email', 'rol')}),
    )

EXPLICACIÓN:
-----------
Este código adapta el panel de administración estándar de usuarios de Django 
para que soporte tu modelo personalizado Usuario, específicamente para 
gestionar el campo extra "rol".

Lo más importante aquí es que heredas de UserAdmin (el admin por defecto de 
Django), lo que mantiene toda la funcionalidad de seguridad (gestión de 
contraseñas, permisos, grupos) y solo le "inyecta" tus personalizaciones.

Detalle:

1. class UsuarioAdmin(UserAdmin):
   - Hereda de la clase base UserAdmin. Si usaras admin.ModelAdmin normal, 
     perderías la lógica especial para manejar contraseñas (hashing) y 
     permisos.

2. list_display = (...)
   - Define las columnas de la tabla de usuarios.
   - Lo relevante es que has añadido 'rol' a la vista, para ver rápidamente 
     si un usuario es Cliente, Administrador, etc.

3. fieldsets = UserAdmin.fieldsets + (...)
   - Controla el formulario de edición de un usuario existente.
   - UserAdmin.fieldsets trae las secciones estándar (Información personal, 
     Permisos, Fechas importantes).
   - El código + (('Información Adicional', {'fields': ('rol',)}),) le agrega 
     una nueva sección al final llamada "Información Adicional" donde 
     aparecerá el selector para cambiar el rol.

4. add_fieldsets = UserAdmin.add_fieldsets + (...)
   - Controla el formulario de creación (cuando le das al botón "Añadir 
     usuario").
   - Por defecto, Django solo pide Usuario y Contraseña al crear.
   - Aquí estás modificando ese formulario inicial para que también pida el 
     email y el rol desde el primer momento.

EN RESUMEN:
Este bloque garantiza que el administrador pueda ver, filtrar, crear y editar 
el campo "rol" de tus usuarios sin perder las herramientas de seguridad 
estándar de Django para el manejo de cuentas.

================================================================================
5. FORMULARIOS DE USUARIO (usuarios/forms.py)
================================================================================

CÓDIGO:
-------
class UsuarioCreationForm(UserCreationForm):
    class Meta:
        model = Usuario
        fields = ('username', 'email', 'first_name', 'last_name', 'rol')

class UsuarioChangeForm(UserChangeForm):
    class Meta:
        model = Usuario
        fields = ('username', 'email', 'first_name', 'last_name', 'rol')

class RegistroForm(UserCreationForm):
    class Meta:
        model = Usuario
        fields = ('email', 'first_name', 'last_name', 'password1', 'password2')
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        for field_name, field in self.fields.items():
            field.widget.attrs['class'] = 'form-control'
        
    def save(self, commit=True):
        user = super().save(commit=False)
        user.username = user.email
        if commit:
            user.save()
        return user

EXPLICACIÓN:
-----------
Este código define tres formularios para trabajar con el modelo Usuario. 
Cada uno tiene un propósito específico:

================================================================================
A. UsuarioCreationForm (Para el Admin)
================================================================================
- Se usa internamente en el panel de administración para crear nuevos usuarios.
- Hereda de UserCreationForm (formulario estándar de Django que maneja 
  contraseñas con hash).
- Incluye el campo 'rol' personalizado de tu modelo.

================================================================================
B. UsuarioChangeForm (Para el Admin)
================================================================================
- Se usa para editar usuarios existentes en el admin.
- Hereda de UserChangeForm (permite cambiar contraseñas de forma segura sin 
  mostrarlas en texto plano).

================================================================================
C. RegistroForm (Para el Usuario Final) ⭐
================================================================================
Este es el más importante y tiene varias particularidades:

a) Campos simplificados:
   - NO pide username explícitamente (se genera automáticamente).
   - NO pide rol (se asigna por defecto en el modelo).
   - Solo pide email, nombre, apellido y contraseña.

b) __init__ - Estiliza el formulario:
   def __init__(self, *args, **kwargs):
       super().__init__(*args, **kwargs)
       for field_name, field in self.fields.items():
           field.widget.attrs['class'] = 'form-control'
   
   - Recorre cada campo y le agrega la clase CSS 'form-control' (Bootstrap).
   - Esto hace que el formulario se vea bonito sin tener que configurar cada 
     campo manualmente en el HTML.

c) save() - Genera username automáticamente:
   def save(self, commit=True):
       user = super().save(commit=False)
       user.username = user.email  # ¡El truco está aquí!
       if commit:
           user.save()
       return user
   
   - PROBLEMA: Django requiere username obligatorio, pero no lo pedimos al 
     usuario.
   - SOLUCIÓN: Toma el email y lo asigna al campo username automáticamente.
   - De esta forma, el usuario puede iniciar sesión con su email, que es más 
     intuitivo.

EN RESUMEN:
- Los dos primeros formularios son para administradores (admin panel).
- RegistroForm es el formulario público que aparece en /registro, diseñado 
  para que los usuarios se registren solo con su email (sin crear un username 
  confuso), y el sistema lo gestiona automáticamente por debajo.

================================================================================
5. ¿Qué es un backend de respaldo?
================================================================================

“Si la wea principal falla, tírate al backend de respaldo que está configurado como el estándar.”

Onda, imagina que tu app web trata de conectarse a un backend específico (por ejemplo, un microservicio fancy que está haciendo magia), pero ese backend no responde, se cayó, o está en modo muerte cerebral.
Entonces, para que tu aplicación no quede como saco wea esperando eternamente, automáticamente usa el backend por defecto. Ese backend por defecto normalmente es el más estable, el más básico, el que siempre debería estar disponible.

En lenguaje más formal (pero no tanto, pa’ no aburrirte):

Fallback = Plan B automático.

Backend por defecto = El servidor o servicio principal que siempre está configurado como “el normal”.

Objetivo = Mantener la continuidad operacional y que el usuario no vea que la app murió como página de la UCT cuando suben mil PDFs al mismo tiempo.

Ejemplo corporativo:

“Si la API de autenticación avanzada no responde, hacemos fallback al backend por defecto para garantizar la experiencia del usuario.”

Traducción chilena:

“Si la API se va a la chucha, usamos la de siempre pa' que la app no pete.”

================================================================================
FIN DEL DOCUMENTO
================================================================================
